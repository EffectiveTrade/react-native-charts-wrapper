//
//  YAxisRenderer.swift
//  Charts
//
//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
//  A port of MPAndroidChart for iOS
//  Licensed under Apache License 2.0
//
//  https://github.com/danielgindi/Charts
//

import Foundation
import CoreGraphics

#if canImport(UIKit)
    import UIKit
#endif

#if canImport(Cocoa)
import Cocoa
#endif

@objc(ChartYAxisRenderer)
open class YAxisRenderer: AxisRendererBase
{
    @objc public init(viewPortHandler: ViewPortHandler, yAxis: YAxis?, transformer: Transformer?)
    {
        super.init(viewPortHandler: viewPortHandler, transformer: transformer, axis: yAxis)
    }

        /// draws the y-axis labels to the screen
        open override func renderAxisLabels(context: CGContext)
        {
            guard let yAxis = self.axis as? YAxis else { return }

            if !yAxis.isEnabled || !yAxis.isDrawLabelsEnabled
            {
                return
            }

            let xoffset = yAxis.xOffset
            let yoffset = yAxis.labelFont.lineHeight / 2.5 + yAxis.yOffset

            let dependency = yAxis.axisDependency
            let labelPosition = yAxis.labelPosition

            var xPos = CGFloat(0.0)

            var textAlign: NSTextAlignment

            if dependency == .left
            {
                if labelPosition == .outsideChart
                {
                    textAlign = .right
                    xPos = viewPortHandler.offsetLeft - xoffset
                }
                else
                {
                    textAlign = .left
                    xPos = viewPortHandler.offsetLeft + xoffset
                }

            }
            else
            {
                if labelPosition == .outsideChart
                {
                    textAlign = .left
                    xPos = viewPortHandler.contentRight + xoffset
                }
                else
                {
                    textAlign = .right
                    xPos = viewPortHandler.contentRight - xoffset
                }
            }

            drawYLabels(
                context: context,
                fixedPosition: xPos,
                positions: transformedPositions(),
                offset: yoffset - yAxis.labelFont.lineHeight,
                textAlign: textAlign)
        }

    /// draws the y-labels on the specified x-position
    open func drawYLabels(
        context: CGContext,
        fixedPosition: CGFloat,
        positions: [CGPoint],
        offset: CGFloat,
        textAlign: NSTextAlignment)
    {
        guard
            let yAxis = self.axis as? YAxis,
            let labelBgColor = yAxis.labelBgColor,
            let transformer = self.transformer
            else { return }
        
        let labelFont = yAxis.labelFont
        
        var labelHeight = CGFloat(10)
        if let font = UIFont(name: labelFont.fontName, size: labelFont.pointSize) {
            let fontAttributes = [NSAttributedString.Key.font: font]
            let labelSize = ("999" as NSString).size(withAttributes: fontAttributes)
            labelHeight = labelSize.height
        }
        
        var limitPositions: [CGPoint] = [CGPoint]()
        let limitLines = yAxis.limitLines
        if limitLines.count > 0
        {
            let trans = transformer.valueToPixelMatrix
            var position = CGPoint(x: 0.0, y: 0.0)
            
            for i in 0 ..< limitLines.count
            {
                let l = limitLines[i]

                if !l.isEnabled
                {
                    continue
                }

                position.x = 0.0
                position.y = CGFloat(l.limit)
                position = position.applying(trans)
                limitPositions.append(position)
            }
        }

        let labelTextColor = yAxis.labelTextColor

        let from = yAxis.isDrawBottomYLabelEntryEnabled ? 0 : 1
        let to = yAxis.isDrawTopYLabelEntryEnabled ? yAxis.entryCount : (yAxis.entryCount - 1)

        let xOffset = yAxis.labelXOffset
        
        var isLimitLabel: Bool = false

        for i in stride(from: from, to: to, by: 1)
        {
            isLimitLabel = false
            for k in 0 ..< limitPositions.count {
                let limitPoint = limitPositions[k]
                if positions[i].y > limitPoint.y - 2 * labelHeight && positions[i].y < limitPoint.y + 2 * labelHeight {
                    isLimitLabel = true
                }
            }
            
            if isLimitLabel {
                continue
            }
            
            let text = yAxis.getFormattedLabel(i)

            if yAxis.labelBgEnabled {
                ChartUtils.drawTextInBox(
                    context: context,
                    text: text,
                    point: CGPoint(x: fixedPosition + xOffset, y: positions[i].y + offset),
                    align: textAlign,
                    bg: labelBgColor.cgColor, padding: yAxis.labelPadding, radius: yAxis.labelRadius,
                    attributes: [.font: labelFont, .foregroundColor: labelTextColor]
                )
            } else {
                ChartUtils.drawText(
                    context: context,
                    text: text,
                    point: CGPoint(x: fixedPosition + xOffset, y: positions[i].y + offset),
                    align: textAlign,
                    attributes: [.font: labelFont, .foregroundColor: labelTextColor]
                )
            }
        }
        
        if limitLines.count == 0
        {
            return
        }
        
        for i in 0 ..< limitLines.count
        {
            let l = limitLines[i]

            if !l.isEnabled
            {
                continue
            }
            
            let label = l.label
            let bgColor = l.labelBgColor!

            if l.labelPosition == .axis
            {
                if l.labelBgEnabled {
                    ChartUtils.drawTextInBox(context: context,
                        text: label,
                        point: CGPoint(x: fixedPosition + xOffset, y: limitPositions[i].y + offset),
                        align: textAlign,
                        bg: bgColor.cgColor, padding: l.labelPadding, radius: l.labelRadius,
                        attributes: [NSAttributedString.Key.font: labelFont, NSAttributedString.Key.foregroundColor: l.valueTextColor])
                } else {
                    ChartUtils.drawText(context: context,
                        text: label,
                        point: CGPoint(x: fixedPosition + xOffset, y: limitPositions[i].y + offset),
                        align: textAlign,
                        attributes: [NSAttributedString.Key.font: labelFont, NSAttributedString.Key.foregroundColor: l.valueTextColor])
                }
            }
        }
    }

    open override func renderAxisLine(context: CGContext)
    {
        guard let yAxis = self.axis as? YAxis else { return }

        if !yAxis.isEnabled || !yAxis.drawAxisLineEnabled
        {
            return
        }

        context.saveGState()

        context.setStrokeColor(yAxis.axisLineColor.cgColor)
        context.setLineWidth(yAxis.axisLineWidth)
        if yAxis.axisLineDashLengths != nil
        {
            context.setLineDash(phase: yAxis.axisLineDashPhase, lengths: yAxis.axisLineDashLengths)
        }
        else
        {
            context.setLineDash(phase: 0.0, lengths: [])
        }

        if yAxis.axisDependency == .left
        {
            context.beginPath()
            context.move(to: CGPoint(x: viewPortHandler.contentLeft, y: viewPortHandler.contentTop))
            context.addLine(to: CGPoint(x: viewPortHandler.contentLeft, y: viewPortHandler.contentBottom))
            context.strokePath()
        }
        else
        {
            context.beginPath()
            context.move(to: CGPoint(x: viewPortHandler.contentRight, y: viewPortHandler.contentTop))
            context.addLine(to: CGPoint(x: viewPortHandler.contentRight, y: viewPortHandler.contentBottom))
            context.strokePath()
        }

        context.restoreGState()
    }

    open override func renderGridLines(context: CGContext)
    {
        guard let
            yAxis = self.axis as? YAxis
            else { return }

        if !yAxis.isEnabled
        {
            return
        }

        if yAxis.drawGridLinesEnabled
        {
            let positions = transformedPositions()

            context.saveGState()
            defer { context.restoreGState() }
            context.clip(to: self.gridClippingRect)

            context.setShouldAntialias(yAxis.gridAntialiasEnabled)
            context.setStrokeColor(yAxis.gridColor.cgColor)
            context.setLineWidth(yAxis.gridLineWidth)
            context.setLineCap(yAxis.gridLineCap)

            if yAxis.gridLineDashLengths != nil
            {
                context.setLineDash(phase: yAxis.gridLineDashPhase, lengths: yAxis.gridLineDashLengths)

            }
            else
            {
                context.setLineDash(phase: 0.0, lengths: [])
            }

            // draw the grid
            positions.forEach { drawGridLine(context: context, position: $0) }
        }

        if yAxis.drawZeroLineEnabled
        {
            // draw zero line
            drawZeroLine(context: context)
        }
    }

    @objc open var gridClippingRect: CGRect
    {
        var contentRect = viewPortHandler.contentRect
        let dy = self.axis?.gridLineWidth ?? 0.0
        contentRect.origin.y -= dy / 2.0
        contentRect.size.height += dy
        return contentRect
    }

    @objc open func drawGridLine(
        context: CGContext,
        position: CGPoint)
    {
        context.beginPath()
        context.move(to: CGPoint(x: viewPortHandler.contentLeft, y: position.y))
        context.addLine(to: CGPoint(x: viewPortHandler.contentRight, y: position.y))
        context.strokePath()
    }

    @objc open func transformedPositions() -> [CGPoint]
    {
        guard
            let yAxis = self.axis as? YAxis,
            let transformer = self.transformer
            else { return [CGPoint]() }

        var positions = [CGPoint]()
        positions.reserveCapacity(yAxis.entryCount)

        let entries = yAxis.entries

        for i in stride(from: 0, to: yAxis.entryCount, by: 1)
        {
            positions.append(CGPoint(x: 0.0, y: entries[i]))
        }

        transformer.pointValuesToPixel(&positions)

        return positions
    }

    /// Draws the zero line at the specified position.
    @objc open func drawZeroLine(context: CGContext)
    {
        guard
            let yAxis = self.axis as? YAxis,
            let transformer = self.transformer,
            let zeroLineColor = yAxis.zeroLineColor
            else { return }

        context.saveGState()
        defer { context.restoreGState() }

        var clippingRect = viewPortHandler.contentRect
        clippingRect.origin.y -= yAxis.zeroLineWidth / 2.0
        clippingRect.size.height += yAxis.zeroLineWidth
        context.clip(to: clippingRect)

        context.setStrokeColor(zeroLineColor.cgColor)
        context.setLineWidth(yAxis.zeroLineWidth)

        let pos = transformer.pixelForValues(x: 0.0, y: 0.0)

        if yAxis.zeroLineDashLengths != nil
        {
            context.setLineDash(phase: yAxis.zeroLineDashPhase, lengths: yAxis.zeroLineDashLengths!)
        }
        else
        {
            context.setLineDash(phase: 0.0, lengths: [])
        }

        context.move(to: CGPoint(x: viewPortHandler.contentLeft, y: pos.y))
        context.addLine(to: CGPoint(x: viewPortHandler.contentRight, y: pos.y))
        context.drawPath(using: CGPathDrawingMode.stroke)
    }

    open override func renderLimitLines(context: CGContext)
    {
        guard
            let yAxis = self.axis as? YAxis,
            let transformer = self.transformer
            else { return }

        let limitLines = yAxis.limitLines

        if limitLines.count == 0
        {
            return
        }

        context.saveGState()

        let trans = transformer.valueToPixelMatrix

        var position = CGPoint(x: 0.0, y: 0.0)

        for i in 0 ..< limitLines.count
        {
            let l = limitLines[i]

            if !l.isEnabled
            {
                continue
            }

            context.saveGState()
            defer { context.restoreGState() }

            var clippingRect = viewPortHandler.contentRect
            clippingRect.origin.y -= l.lineWidth / 2.0
            clippingRect.size.height += l.lineWidth
            context.clip(to: clippingRect)

            position.x = 0.0
            position.y = CGFloat(l.limit)
            position = position.applying(trans)

            context.beginPath()
            context.move(to: CGPoint(x: viewPortHandler.contentLeft, y: position.y))
            context.addLine(to: CGPoint(x: viewPortHandler.contentRight, y: position.y))

            context.setStrokeColor(l.lineColor.cgColor)
            context.setLineWidth(l.lineWidth)
            if l.lineDashLengths != nil
            {
                context.setLineDash(phase: l.lineDashPhase, lengths: l.lineDashLengths!)
            }
            else
            {
                context.setLineDash(phase: 0.0, lengths: [])
            }

            context.strokePath()

            let label = l.label
            let labelBgColor = l.labelBgColor!

            // if drawing the limit-value label is enabled
            if l.drawLabelEnabled && label.count > 0
            {
                let labelLineHeight = l.valueFont.lineHeight

                let xOffset: CGFloat = 4.0 + l.xOffset
                let yOffset: CGFloat = l.lineWidth + labelLineHeight + l.yOffset
                
                var labelWidth = CGFloat(0)
                if let font = UIFont(name: l.valueFont.fontName, size: l.valueFont.pointSize) {
                    let fontAttributes = [NSAttributedString.Key.font: font]
                    let labelSize = (label as NSString).size(withAttributes: fontAttributes)
                    labelWidth = labelSize.width
                }
                
                if l.labelPosition == .topRight
                {
                    if l.labelBgEnabled {
                        ChartUtils.drawTextInBox(context: context,
                            text: label,
                            point: CGPoint(
                                x: viewPortHandler.contentRight - xOffset - labelWidth / 2,
                                y: position.y - yOffset),
                            align: .right,
                            bg: labelBgColor.cgColor, padding: l.labelPadding, radius: l.labelRadius,
                            attributes: [NSAttributedString.Key.font: l.valueFont, NSAttributedString.Key.foregroundColor: l.valueTextColor])
                    } else {
                        ChartUtils.drawText(context: context,
                            text: label,
                            point: CGPoint(
                                x: viewPortHandler.contentRight - xOffset,
                                y: position.y - yOffset),
                            align: .right,
                            attributes: [NSAttributedString.Key.font: l.valueFont, NSAttributedString.Key.foregroundColor: l.valueTextColor])
                    }
                }
                else if l.labelPosition == .bottomRight
                {
                    if l.labelBgEnabled {
                        ChartUtils.drawTextInBox(context: context,
                            text: label,
                            point: CGPoint(
                                x: viewPortHandler.contentRight - xOffset - labelWidth / 2,
                                y: position.y + yOffset - labelLineHeight),
                            align: .right,
                            bg: labelBgColor.cgColor, padding: l.labelPadding, radius: l.labelRadius,
                            attributes: [NSAttributedString.Key.font: l.valueFont, NSAttributedString.Key.foregroundColor: l.valueTextColor])
                    } else {
                        ChartUtils.drawText(context: context,
                            text: label,
                            point: CGPoint(
                                x: viewPortHandler.contentRight - xOffset,
                                y: position.y + yOffset - labelLineHeight),
                            align: .right,
                            attributes: [NSAttributedString.Key.font: l.valueFont, NSAttributedString.Key.foregroundColor: l.valueTextColor])
                    }
                }
                else if l.labelPosition == .topLeft
                {
                    if l.labelBgEnabled {
                        ChartUtils.drawTextInBox(context: context,
                            text: label,
                            point: CGPoint(
                                x: viewPortHandler.contentLeft + xOffset,
                                y: position.y - yOffset),
                            align: .left,
                            bg: labelBgColor.cgColor, padding: l.labelPadding, radius: l.labelRadius,
                            attributes: [NSAttributedString.Key.font: l.valueFont, NSAttributedString.Key.foregroundColor: l.valueTextColor])
                    } else {
                        ChartUtils.drawText(context: context,
                            text: label,
                            point: CGPoint(
                                x: viewPortHandler.contentLeft + xOffset,
                                y: position.y - yOffset),
                            align: .left,
                            attributes: [NSAttributedString.Key.font: l.valueFont, NSAttributedString.Key.foregroundColor: l.valueTextColor])
                    }
                }
                else if l.labelPosition == .bottomLeft
                {
                    if l.labelBgEnabled {
                        ChartUtils.drawTextInBox(context: context,
                            text: label,
                            point: CGPoint(
                                x: viewPortHandler.contentLeft + xOffset,
                                y: position.y + yOffset - labelLineHeight),
                            align: .left,
                            bg: labelBgColor.cgColor, padding: l.labelPadding, radius: l.labelRadius,
                            attributes: [NSAttributedString.Key.font: l.valueFont, NSAttributedString.Key.foregroundColor: l.valueTextColor])
                    } else {
                        ChartUtils.drawText(context: context,
                            text: label,
                            point: CGPoint(
                                x: viewPortHandler.contentLeft + xOffset,
                                y: position.y + yOffset - labelLineHeight),
                            align: .left,
                            attributes: [NSAttributedString.Key.font: l.valueFont, NSAttributedString.Key.foregroundColor: l.valueTextColor])
                    }
                }
            }
        }

        context.restoreGState()
    }
}
